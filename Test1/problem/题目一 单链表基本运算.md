【问题描述】
设计并实现线性表的单链表存储和运算。
【基本要求】
实现单链表的插入、删除和遍历运算，每种操作用一个函数实现。
插入操作：将一个新元素插入表中指定序号的位置。
删除操作：将指定序号的元素从表中删除。
遍历操作：从表头按次序输出所有元素的值，若是空表，则输出信息“empty list!”。
【实现提示】
1. 程序运行时，首先在 main 函数中创建空的、带头结点的单链表。然后多次调用实现插入操作
5
的函数（每次都将元素在序号 1 位置上插入），将元素依次插入表中，最后调用实现遍历操作的函数输
出所有元素。之后再多次调用实现删除操作的函数将表还原为空表（每次都删除第 1 个元素，每删除
一个元素后，将表中剩余元素都输出一次）。
2. 单链表结点类型定义：
```c
typedef int ElemType; //为简化起见，元素类型定义为整型
typedef struct Node{
ElemType data;
struct Node *next;
}Node, *LinkList;
```
3. 为了简化指针参数传递，使用 c++的引用参数，存储源程序时注意后缀名应为 cpp。 （其他实
验题目在此处的处理相同）
4．创建链表时，可以多次调用插入函数（插入函数的功能是在链表的第 i 个元素结点前插入一个
新结点），通过不断地在链表中增加结点来实现，也可以定义一个专门创建链表的函数，调用一次该函
数就完成链表中所有结点的创建（当然，此后需要在链表中插入一个新结点时调用前述的插入函数即
可）。
例如，用头插法创建长度为 n 的单链表的函数定义如下：
```c
Status CreateList_L(LinkList &L, int n)
{ //用表头插入法逆序建立长度为 n 的、带头结点的单链表
int i;
LinkList p;
L = (LinkList) malloc(sizeof(Node));
if (!L)
return INFEASIBLE;
L->next = NULL; //建立仅有头结点的单链表
for(i=n; i>0; --i) { //输入 n 个整数，逐个插入单链表中
p = (LinkList)malloc(sizeof(Node)); //生成新结点
if (!p)
return INFEASIBLE;
scanf("%d",&p->data); //从键盘输入元素值，存入新结点中
p->next = L->next; L->next = p; //新结点插入到表头
}
return OK;
}
```
【测试数据】
```
输入数据：1 2 3 4 5 0（为 0 时结束，0 不存入链表）
第一次输出：5 4 3 2 1
第二次输出：4 3 2 1
第三次输出：3 2 1
第四次输出：2 1
第五次输出：1
第六次输出：empty list!
```